I"€R<h3 id="part-0">Part 0</h3>

<p>This is a study note for <a href="http://pmem.io/2015/06/12/pmem-model.html">this page</a>.</p>

<p>Nowadays, there are two kinds of memory:</p>

<ul>
  <li>fast, byte addressable, volatile memory</li>
  <li>slower, persistent, block storage</li>
</ul>

<p>This library, combined with the right hardware (NVDIMMs‚Äînon-volatile dual-in-line memory module), provides a way of utilizing a third type of memory: fast, byte addressable and persistent.</p>

<p>It‚Äôs not necessary to run this library with a real persistent memory in the platform, all that is really necessary is a device with a file system (performance will be different).</p>

<h3 id="part-1---accessing-the-persistent-memory">Part 1 - accessing the persistent memory</h3>

<h5 id="memory-pool">Memory pool</h5>

<p>Persistent memory is exposed by the OS as memory-mapped files, which is called pools.</p>

<p><img src="/assets/images/screenshot66.png" alt="img" /></p>

<h5 id="persistent-pointers">Persistent pointers</h5>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">pmemoid</span> <span class="p">{</span> 
        <span class="kt">uint64_t</span> <span class="n">pool_uuid_lo</span><span class="p">;</span> 
        <span class="kt">uint64_t</span> <span class="n">off</span><span class="p">;</span> 
<span class="p">}</span> <span class="n">PMEMoid</span><span class="p">;</span>
</code></pre></div></div>

<p>In a very basic view, a regular pointer is a number of bytes between the start of the virtual address space to the beginning of the thing it points to. The persistent pointer is twice the size of a regular pointer and contains the <strong>offset from the start of the pool</strong> and <strong>unique id of the pool</strong>.</p>

<p>The pool id is used to figure out where the pool is currently mapped (because the actual address of the memory mapped region can be different each time the application started).</p>

<p>If the virtual address the pool is mapped at is known, we can get the direct pointer by performing a simple addition:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">pool</span> <span class="o">+</span> <span class="n">oid</span><span class="p">.</span><span class="n">off</span><span class="p">)</span>
</code></pre></div></div>

<p>All open pools are stored in a <a href="http://en.wikipedia.org/wiki/Cuckoo_hashing">cuckoo hash table</a> with 2 hashing functions.</p>

<h5 id="the-root-object">The root object</h5>

<p>The known location you can always look for in the memory pool is the root object. It‚Äôs the anchor to which all the memory structures can be attached. The root object is <strong>initially zeroed</strong>.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PMEMoid</span> <span class="n">root</span> <span class="o">=</span> <span class="n">pmemobj_root</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">my_root</span><span class="p">));</span>
</code></pre></div></div>

<p>The root object is allocated from the pool and when an in-place reallocation is impossible a new object will be created with a different offset. So <strong>be careful when trying to store the root persistent pointer</strong> because it might change.</p>

<h5 id="safely-storing-data">Safely storing data</h5>

<p>When creating programs that write to persistent memory we have to be extra careful to make sure that the application is always in a state we can recognize and use, regardless of the exact moment is was interrupted.</p>

<p>Consider the following code:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">set_name</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">my_name</span><span class="p">)</span> <span class="p">{</span>
<span class="n">memcpy</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">my_name</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">my_name</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If the application crashes in the middle of the copying or if cacheline didn‚Äôt get flushed in time, we might not get what we want.</p>

<p>It should be written like this</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">set_name</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">my_name</span><span class="p">)</span> <span class="p">{</span>
<span class="n">root</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">my_name</span><span class="p">);</span>
<span class="n">pmemobj_persist</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">));</span>
<span class="n">pmemobj_memcpy_persist</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">my_name</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <span style="color: #0000ff;">_persist </span> suffixed functions make sure that the range of memory they operate on is flushed from the CPU and safely stored on the medium, whatever that might be.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">pmemobj_persist</span><span class="p">(</span><span class="n">PMEMobjpool</span> <span class="o">*</span><span class="n">pop</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
</code></pre></div></div>

<p><span style="color: #0000ff;">pmemobj_persist()</span> forces any changes in the range [<em>addr</em>, <em>addr</em>+<em>len</em>) to be stored durably in persistent memory.</p>

<p>The fundamental principle is that, on the current hardware architecture, only 8 bytes of memory can be written in an <strong>atomic</strong> way(ÂéüÂ≠êÊìç‰Ωú). So this is correct:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">root</span><span class="o">-&gt;</span><span class="n">u64var</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
<span class="n">pmemobj_persist</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">u64var</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
</code></pre></div></div>

<p>But this is wrong:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">root</span><span class="o">-&gt;</span><span class="n">u64var</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
<span class="n">root</span><span class="o">-&gt;</span><span class="n">u32var</span> <span class="o">=</span> <span class="mi">321</span><span class="p">;</span>
<span class="n">pmemobj_persist</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">u64var</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
</code></pre></div></div>

<p>#####</p>

<h5 id="example">Example</h5>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * layout.h -- example from introduction part 1
 */</span>


<span class="cp">#define LAYOUT_NAME "intro_1"
#define MAX_BUF_LEN 10
</span>
<span class="k">struct</span> <span class="n">my_root</span> <span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MAX_BUF_LEN</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*
 * writer.c -- example from introduction part 1
 */</span>

<span class="cp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;libpmemobj.h&gt;
</span>
<span class="cp">#include "layout.h"
</span>
<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"usage: %s file-name</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">PMEMobjpool</span> <span class="o">*</span><span class="n">pop</span> <span class="o">=</span> <span class="n">pmemobj_create</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">LAYOUT_NAME</span><span class="p">,</span>
				<span class="n">PMEMOBJ_MIN_POOL</span><span class="p">,</span> <span class="mo">0666</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pop</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">perror</span><span class="p">(</span><span class="s">"pmemobj_create"</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">PMEMoid</span> <span class="n">root</span> <span class="o">=</span> <span class="n">pmemobj_root</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_root</span><span class="p">));</span>
	<span class="k">struct</span> <span class="n">my_root</span> <span class="o">*</span><span class="n">rootp</span> <span class="o">=</span> <span class="n">pmemobj_direct</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MAX_BUF_LEN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scanf</span><span class="p">(</span><span class="s">"%9s"</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span> <span class="o">==</span> <span class="n">EOF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"EOF</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rootp</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="n">pmemobj_persist</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rootp</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rootp</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">));</span>

	<span class="n">pmemobj_memcpy_persist</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">rootp</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">rootp</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

	<span class="n">pmemobj_close</span><span class="p">(</span><span class="n">pop</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
 * reader.c -- example from introduction part 1
 */</span>

<span class="cp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;libpmemobj.h&gt;
</span>
<span class="cp">#include "layout.h"
</span>
<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"usage: %s file-name</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">PMEMobjpool</span> <span class="o">*</span><span class="n">pop</span> <span class="o">=</span> <span class="n">pmemobj_open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">LAYOUT_NAME</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pop</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">perror</span><span class="p">(</span><span class="s">"pmemobj_open"</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">PMEMoid</span> <span class="n">root</span> <span class="o">=</span> <span class="n">pmemobj_root</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_root</span><span class="p">));</span>
	<span class="k">struct</span> <span class="n">my_root</span> <span class="o">*</span><span class="n">rootp</span> <span class="o">=</span> <span class="n">pmemobj_direct</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rootp</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">==</span> <span class="n">strlen</span><span class="p">(</span><span class="n">rootp</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">))</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">rootp</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>

	<span class="n">pmemobj_close</span><span class="p">(</span><span class="n">pop</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Functions:</p>

<ul>
  <li>
    <p><span style="color: #0000ff;">pmemobj_create</span></p>

    <p>Creates a pool. It takes the usual paramaters, and creates a file pus a layout. A layout is a string of your choosing that identifies the pool.</p>

    <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PMEMobjpool</span> <span class="o">*</span><span class="nf">pmemobj_create</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">layout</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">poolsize</span><span class="p">,</span> <span class="n">mode_t</span> <span class="n">mode</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><span style="color: #0000ff;">pmemobj_open</span></p>

    <p>Opens existing pools. Requires that the layout passed to it matches the one the pool was created with.</p>

    <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PMEMobjpool</span> <span class="o">*</span><span class="nf">pmemobj_open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">layout</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><span style="color: #0000ff;">pmemobj_close</span></p>

    <p>Release the pool when it is no longer used.</p>

    <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">pmemobj_close</span><span class="p">(</span><span class="n">PMEMobjpool</span> <span class="o">*</span><span class="n">pop</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><span style="color: #0000ff;">pmemobj_check</span></p>

    <p>Verifies if all the required metadata is consistent.</p>

    <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">pmemobj_check</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">layout</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><span style="color: #0000ff;">pmemobj_direct</span></p>

    <p>Takes the PMEMoid (persistent pointer) and turns it into a regular one that can be dereferenced.</p>

    <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="nf">pmemobj_direct</span><span class="p">(</span><span class="n">PMEMoid</span> <span class="n">oid</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><span style="color: #0000ff;">pmemobj_persist</span></p>

    <p>forces any changes in the range [addr, addr+len) to be stored durably in persistent memory.</p>

    <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">pmemobj_persist</span><span class="p">(</span><span class="n">PMEMobjpool</span> <span class="o">*</span><span class="n">pop</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
</ul>
:ET